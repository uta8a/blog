---
layout: post
title: プログラミング意味論の基礎を読みました
description: プログラミング意味論の基礎を読んでいる途中のメモ
draft: false
changelog:
  - summary: 記事作成
    date: 2020-10-26T14:56:27+09:00
  - summary: hugoにmigrate
    date: 2022-05-25T07:19:22+09:00
---

- また読んでいる途中です。

## 第 1 章

- 1.1 演習問題がやさしいなと思ったらいっぱい間違えた。「ならば」の使い方が難しい。
- 2 項関係が直積(感覚的には 組 だと思えば OK)の部分集合を指していることの理解に苦労した。まず、関係とは例として `<` が考えられるけど、 `1<2` を見ると 1,2 の間に挟まっているやつなのにこれが集合になる？？？という記号に対する違和感を持った。実際は、 `x<y` は `(x,y)` が満たす条件を定めていて、その条件を満たすような `(x,y)` を集めているのでこれは直積の部分集合になる。
- 関数もそうだが、今まで習ってきた `x<y` や `f(x)=y` という表記に慣れすぎていて、それらを統一的に二項関係 `(x,y)∈R` という観点からまとめ直すことに苦労した。
- 対角線論法の理解で、 `f(n)(n)` の意味を理解するところで苦労した。まず勘違いとして、 `f(n)` は 0,1 のいずれかだと思っていた。この勘違いのもとでは `f(n)` は関数ではないので `f(n)(n)` はおかしいことになる。幸い Twitter でフォローしている方に教えてもらって、 `f` は Nat -> {0,1}への関数を集めたものなので、 `f(n)` は(それら関数たちを番号付けできたという仮定をして)、n 番目の関数であるという意味にあたることが理解できた。したがって、 `f(n)(n)` は「n 番目の関数に引数 n を渡したもので、0 or 1 を返す」という理解になる。こうすれば、 `g=f(m)` なら `(f(m))(m)=0` は `f(m)(m)=0` となることが理解でき、後半のパートも理解できる。

## 第 2 章

- 2.2 曖昧な構文が存在しないように BNF を構成するところが苦労した。以下のように構成するとうまくいくことが多い気がする
- とりあえず下のやつを最初に持ってきて、後ろに書くやつをうまく考える

```
A ::= B | ~
B ::= C | ~
C ::= (A) | ~
```

- 2.3 具象構文と抽象構文の違いについての理解。構文解析を行うと、それは構文として正しい構造を持つことがチェックされているので、このパートで構造チェック(演算子の優先度や、括弧の有無)が走っている。そこで次に意味論パート(構造は合っているが、意味として正しいか？)に移るので、ここでは構造としての正しさを考えなくてよい。したがって、括弧の有無などは抽象構文では気にしなくてよいことになる。
